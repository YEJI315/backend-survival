# 🥑 REST API

API란 Application Programming Interface의 약자인데, 나는 API가 서버에 요청을 보내면 사용자는 그 내부를 알 수 없더라도 원하는 결과를 가져올 수 있도록 하는 편리한 소프트웨어  도구라고 생각한다.&#x20;

REST API와 SOAP API를 많이들 비교하길래 SOAP이 뭔지 궁금해졌다.&#x20;

&#x20;SOAP API는 Simple Object Access Protocol으로 그 자체로 프로토콜이다. 그렇기 때문에 보안이나 메시지전송 등에 있어 REST보다 더 많은 표준들이 정해져 있기 때문에 더 복잡하다. 보안이나 트랜잭션 등등 많은 규칙들을 준수해야 하기 때문에 웹 서비스 보다는 기업용 애플리케이션이나 은행어플같은 보안수준이 높아야 하는 경우에 선호된다.

REST API란 Representational State Transfer API 의 약자로, 웹 애플리케이션이 제공하는 각각의 데이터를 리소스 즉, 자원으로 간주하고 각각의 자원에 고유한 URI를 할당함으로써 이를 표현하는 API를 정의하기 위한 소프트웨어 아키텍쳐 스타일이다. 네트워크를 통해서 컴퓨터들끼리 통신할 수 있게 해주고  식별자(URI)와 HTTP프로토콜을 기반으로 한다. 데이터 포맷은 브라우저 간 호환성이 좋은 JSON을 사용한다. 클라이언트 서버 모델로 구축되어 그사이에서 통신할 수 있게하고, 아키텍처를 만들 수 있게 한다. 단일 인터페이스를 사용하기 때문에 해당 API를 사용하는 애플리케이션들이 동일한 경로를 통해 접속해야하고, 그 방식이 단순하다.

REST API는 서버에 URI를 이용하여 접근하지만 SOAP은 프로토콜이기 때문에 서비스 인터페이스를 통해 서버에 접근한다.

어쨌든 두 방식의 큰 차이는 프로토콜이냐 아키텍쳐냐 인데, 프로토콜은 통신규약이고 아키텍쳐는 그 통신규약을 이용해서 서비스를 만드는 구조 정도로 이해했다.&#x20;

정보은닉과 캡슐화 : 학원 다닐 때 단순히 정보은닉 = 캡슐화 로 이해했는데, 정보은닉에 캡슐화가 포함되어 있었다. 정보은닉은 1.업캐스팅(자식 객체의 타입을 부모 객체의 타입으로 형변환 함으로써 구체적인 자식 객체의 타입을 은닉) 2.캡슐화 3.인터페이스&추상클래스 의 방법으로 보다 다형하게 구현이 가능하다.

아키텍처와 아키텍처 스타일 : 아키텍처란 소프트웨어를 구성하고있는 부품들 간의 연결관계이다. 소프트웨어를 어떻게 구조화 시켜야 하는지, 상위메뉴와 하위메뉴를 어떻게 배치해야 하는지 등등.. 소프트웨어를 구성하고 있는 기능 하나하나를 어떻게 관계시킬지에 대한 모든 구조적인 문제.. 아키텍처 스타일은 이러한 아키텍처 설계에서 반복해서 나타나는 문제를 해결하고 아키텍처가 만족시켜야 하는 시스템 품질 속성을 달성할 수 있는 방법을 체계화 한 것.

REST -> 필딩 제약조건을 따르느냐 안따르느냐가 중요

## REST 제약조건 7가지

1. Starting with the Null Style : 설계자는 어떠한 제약조건 없이 시스템의 전반에서 시작하여 점진적으로 제약조건을 추가한다. 그리고 추가한 제약조건들이 시스템 내에서 조화롭고 자연스럽게 동작할 수 있도록 설계를 진행. 시스템의 맥락에 대한 이해와 규제를 강조하는 관점.&#x20;
2. Client-Server : 사용자 인터페이스에 대한 관심을 데이터 저장에 대한 관심으로부터 분리. 클라이언트 측면에서는 여러 플랫폼에 대한 사용자 인터페이스의 이식성을 개선시키고, 서버 측면에서는 서버측 구성요소를 단순화함으로써 확장성을 개선.
3. Stateless : 클라이언트와 서버는 서로의 상태를 모른다. 그러므로 클라이언트가 서버로 보내는 요청에는 해당 요청을 이해하는 데에 필요한 모든 정보가 담겨있어야 한다!
4. Cache : 캐시가 가능해야 한다. 즉 모든 서버의 응답은 캐시 가능한지 아닌지 알 수 있어야 한다. 효율, 규모확장성, 사용자 입장에서의 성능이 개선된다.
5. Uniform Interface → 핵심! 이 제약조건을 가장 만족 못한다.

* identification of resources : resource가 URI로 식별되면 됨.
* manipulation of resources through representations : resource CRUD 작업시 요청을 담아 전송해서 resource 조작을 달성하면 됨.
* self-descriptive messages : 메시지는 스스로를 설명해야한다. 자기서술적! -> MIME 타입으로 설명해줄 수 있다.  홀맨   왈 "자기 서술이란 건 결국 내가 나를 설명했을 때 내가 누구인지 받아들이는 쪽에서 이해가 된다는 겁니다. 받아들이는 쪽에서 이해하지 못하면 자기 서술적이지 않죠." 서버나 클라이언트가 변경되더라도 오고가는 메시지는 언제나 자기서술적이므로 언제나 해석 가능하다.
* hypermedia as the engine of application state (HATEOAS) : 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야한다. html같은 경우 이를 만족한다. ex)\<a href="/test">test\</a> 누름으로써 원하는 상태로 전이가 가능하기 때문에 hateoas 만족! 어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 즉, 링크는 동적으로 변경될 수 있다.

6. Layered System : 각 레이어는 인접하지 않은 레이어의 정보를 몰라야 한다! 어떤 시스템이 가지고 있는 지식을 단일 계층으로 제한함으로써 전체적인 시스템의 복잡도를 감소시킴.
7. Code-On-Demand (optional) : 서버에서 코드를 클라이언트로 보내서 실행할 수 있어야한다. 서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야 한다. ex)자바스크립트

> JSON 같은 범용 포맷을 작게 사용하면 어떻게 해석해야 하는지 알 수 없기 때문에 자기서술적이기 어렵다. 뒤에서 다룰 MIME 타입으로 설명한다면, application/json이 아니라 application/dns+json 같은 타입을 써야 한다 dns를 요청하고 그것에 대한 응답을 json으로 받겠다 라는 자기서술

> REST API를 이야기할 때 까다로운 부분 중 하나
>
> 내 블로그를 만들면서  rest api를 쓴다고 하자 내 블로그용 api나 어떤 포맷을 만들어서 등록을 한다? 물론  기존에 적절한 포맷이 존재함  과연 그것이 레스트풀 하다고 할 수 있을까 -> 범용이 아니니까 자기 서술적이 아니니까..
>
>
>
> resource는 추상이다. 모든 시간에 통용되는 엔티티의 집합
>
> resource와 표현을 분리 리소스, 표현, 실제 데이터 등은 전부 구분된다. (rest에서 중요한 부분)
>
>
>
> 리차드슨 성숙도 모델 : 리소스와 http verbs만으로도 rest에 훨씬 가까워 짐. 링크를 씀으로써 완성.

Hateous : Hypermedia As the Engine of Application State. 하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 매커니즘으로 사용한다. (REST API를 잘 설계하기 위해 나온 개념) -> REST API를 사용하는 클라이언트가 전적으로 서버와 동적인 상호작용이 가능하도록 하는 것을 의미한다. 클라이언트가 서버로부터 어떠한 요청을 할 때 요청에 필요한 URI를 응답에 포함시켜 반환하는 것으로 가능하게 함. 구현은 쉬우나 잘 안지키는 경우가 다반사. 웹 브라우저에서 항상 쓰는 것. ex)어떤 버튼을 누르면 상태가 바뀌는 것. 이렇게 하려면 표현에 선택 가능한 상태전환이 포함되어야 한다. 대부분은 효율 문제로 링크보다는 매뉴얼을 보고 처리한다. REST 요구조건을 충족시키지 못한채로 개발..

URI : 리소스를 식별하는 방법. 식별할 때는 식별자를 활용. 방법은 두가지, 1. URL - 리소스의 위치. 위치변경에 취약함 2. URN - 리소스의 유니크한 이름. 사실상 쓰이지 않음.&#x20;

URI라고 쓰는건 대부분 URL을 의미! 따라서 URI와 URL을 크게 구별하지 않고 동의어에 가깝게 사용.

리소스에 대한 표현으로 MIME Type(Content Type, Media Type) 사용 : 서버에 요청할 때도 넣어줌.

&#x20;1\. text/plain : 이메일에서 자주 사용.&#x20;

2. text/html : 일반적인 웹 문서. html 문서.
3. text/css : css파일
4. text/javascript : javascript 파일
5. application/xml : 범용. 자기서술적이기 어렵다. 애플리케이션과 xml을 이용해서 뭔가 작동할 수 있다는 의미. 범용이라 자기서술적이기 상대적으로 어렵다.
6. application/atom+xml&#x20;
7. application/json : 범용. 자기서술적이기 굉장히 어렵다. 아 나는 데이터일 뿐이야!
