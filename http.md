# 🥑 HTTP 기초

OSI 7계층

1. 물리계층 : 논리 데이터 구조를 기초로 하는 필수계층. 기계영역.
2. 데이터링크 : 하드웨어를 추상화한 물리적 주소(MAC) 부여.
3. 네트워크 : 여러개의 노드를 거칠 때 마다 경로를 찾아주는 역할을 함. IP 주소를 부여하고 ROUTER로 경로를 설정해 서로를 인식할 수 있게 함.
4. 전송 : End to End. 패킷을   생성해사용자들이 신뢰성 있는 데이터를 주고받게 해줌.&#x20;
5. 세션 : 통신을 하기 위한 세션을 확립/유지/중단
6. 표현 : 코드간의 번역. 인코딩
7. 응용 : http 등 네트워크 소프트웨어 UI 부분. 사용자 I/O부분

URL : 리소스를 특정하기 위해서. \~주세요 라고 하기 위해 쓴다.

멱등성 : 동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고 서버의 상태도 동일하게 남을 때 멱등성을 가졌다고 한다.&#x20;

대표적으로  GET 요청이 있는데, 이는 아무리 요청을 보내도 동일한 결과를 반환하며 서버의 상태도 변하지 않는다. CREATE를 위해 사용하는 POST 요청은 요청을 보낼 때 마다 새로운  ROW 가 생성되어 서버의 상태가 변하기 때문에 멱등성을 갖고 있지 않다. UPDATE 또한 그렇다.&#x20;

DELETE가 좀 헷갈릴 법 한데, DELETE/idx/delete HTTP/1.1 이렇게 요청을 보내면 해당 ROW가 지워져 또 요청을 보내면 404를 반환한다. 하지만 멱등성을 가지고 있다. 그 이유는 요청을 여러번 보내더라도 해당 리소스는 삭제된 상태 그대로이니 서버의 상태가 변하지 않기 때문이다.&#x20;

HTTP Status code : 상태 코드 중, 304는 redirect시 캐시에 있는 데이터를 사용한다. 아예 새로 들어가는 경우에는 200이 뜬다.

TCP : 연결이 필요. 전달 및 순서 보장. (전화)

UDP : 연결하지 않고 데이터를 보냄. 전달 및 순서를 보장하지 않음. (편지)

이들을 어떻게 쓸거냐? SOCKET을 이용한다. SOCKET이란 END POINT, 서버의 END와 클라이언트의 END를 SOCKET API를 이용해 연결한다.

STREAM : 자바에서 지원하는 기능이 아닌 OS 차원에서 지원하는 기능이다. '연결통로' 로 이해했다. 각각 다른 프로그램을 실행하더라도 스트림을 이용하면 연결이 가능하다.

## HTTP Client

1. Connect : IP번호와 PORT번호만 알면 소켓을 이용해 서버에 접속할 수 있다.&#x20;
2. Request : 요청 메시지를 만들고 TCP로 전송한다. 요청메시지는&#x20;

"""GET / HTTP/1.1

Host: example.com



""";&#x20;

이런 식으로 넣는다. 빈 줄을 빼먹으면 안됨. 소켓에서  Output Stream을 얻어서 쓸 수 있고, Byte Array로문보내야 한다는 특징이 있다.  문자열을  직접 전송하고 싶다면 Writer를 쓴다. Writer는내부적으로 버퍼가 있기 때문에 flush를 잊지 않아야 한다.

버퍼 : 버퍼란 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 잠깐 그 데이터를 보관하는 메모리의 영역이다. 그러므로 flush를 이용하여 버퍼에 저장되어 있는 내용을 클라이언트로 전송하고 버퍼를 비워줘야 한다.

3. Response : 소켓에서 Input Stream을 얻어서 쓸 수 있다. Byte Array를 보냈기 때문에 Byte Array를 읽어와야 한다.  Byte 배열을 준비하고 데이터를 읽어오는데, 읽어오는 것에 대한 길이를 리턴한다. 응답된 데이터가 우리가 준비한 배열보다 클 수도 있어 반복해서 여러번 읽는 작업이 필요할 수도 있다.요청과 마찬가지로 Reader를 쓰면 더 편리한데, 이 또한 버퍼에 담기기 때문에 flip을 잊지 않아야 한다.&#x20;

flip : 읽기 모드로 바꾸는 것. 예를 들어 버퍼에 a b c d를 담았고 읽기 모드로 바꿔 a b c를 읽었다면 버퍼에는  d만 남아있는 상태가 된다.&#x20;

4. Close : 소켓은 Closeable 이기 때문에 try-with-resources문을 이용해도 된다.

try-with-resources와 try-catch-finally : try-catch-finally문은 예외 발생으로 인한 프로세스의 비정상 종료를 막고 정상적인 실행상태를 유지하기 위한 것이다. 하지만 자바 7 이전에는 try-catch-finally문을 이용할 시 finally 블록에서 null체크 후 close를 직접 호출해 자원을 반납  해야했는데, 이러한 과정은 1.자원반납으로 코드 복잡 2.번거로움 3.자원이 반납되지 않는 실수가 잦다 라는 문제점이 있었다. 이런 문제점을 해결하기 위해 try-with-resources 문법이 추가 되었다. 이 문법은 closeable을 상속받고 있는 자원이라면 try블럭이 끝나자 마자 자동으로 close 된다.

Java ServerSocket : java에서 서버 프로그램을 개발할 때 쓰이는 클래스. 해당 클래스는 클라이언트에서 서버로 접속하거나 서버에서 accept 하는데 필요한 클래스임.&#x20;

Blocking vs Non-Blocking : TCP소켓의 Blocking 모드는 소켓이 블록 되는 것을 의미한다. 즉, tcp 통신에서 서버가 클라이언트의 요청을 받을 준비를 하고 클라이언트의 접속을 기다리는걸 의미한다! 만약 애플리케이션이 싱글스레드 모델이라면 블록상태에서 문제가 생겼을 경우 다음 처리를 진행할 수 없기 때문에 문제가 될 수 있다. 입력 스트림의 read() 출력 스트림의 write() 메소드를 호출하면 블로킹 된다. IO 스레드가 블로킹 되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트도 할 수 없고 블로킹을 빠져나오는 방법은 스트림을 닫는 것이다. 그래서 Non-Blocking 모델이 나왔다.&#x20;

Non-Blocking 모델은 소켓이 블록 되지 않고 즉시 소켓의 상태를 반환한다. 이렇게 되면 소켓의 상태를 주기적으로 체크하고 다른 처리를 진행할 수 있게 된다.   NIO의 넌블로킹은 스레드를 인터럽트 함으로써 빠져나올 수 있다. 입출력 준비가 완료된 채널만 선택해서 작업 스레드가 처리하기 때문에 작업 스레드가 블로킹 되지 않는다.&#x20;

JAVA IO와 NIO : JAVA가 특별히 성능이 좋지 않은 부분은 IO이다. 이 IO 성능 문제를 개선하는 것이 바로 java.nio 패키지 이다. IO는 스트림 기반이다. 스트림은 입력과 출력 스트림으로 구분되어 있기 때문에 데이터를 읽기 위해서는 입력 스트림을, 출력하기 위해서는 출력 스트림을 생성해야 한다. NIO는 채널 기반이고, 채널은 스트림과 달리 양방향으로 입출력이 가능하다. 또한 블로킹과 넌블로킹 방식을 모두 지원한다.

자바 람다식 : 자바8부터 도입된 람다식은 익명 함수로, 메서드 이름이 존재하지 않으며 매개변수와 함수의 본문이 존재하는 메서드이다. 람다식 구문은 (매개변수) -> 메서드 본문 형태로 진행된다.

자바 함수형 인터페이스 : 함수형 인터페이스란 1개의 추상 메소드를 갖는 인터페이스이다. 추상 메서드가 하나라는 뜻은 default method 또는 static method는 여러개 존재해도 상관 없다는 것. @FunctionalInterface 어노테이션을 사용, 이 어노테이션은 해당 인터페이스가 함수형 인터페이스 조건에 맞는지 검사해준다.&#x20;
